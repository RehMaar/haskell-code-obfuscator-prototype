module Utils where import qualified GHC; import qualified OccName as GHC; import qualified RdrName as GHC; import qualified Name as GHC; import Data.List; import Data.Generics as SYB; import Control.Arrow ( (&&&), first ); import Outputable as Out; unique :: Ord a => [a] -> [a]; a18 = (((.) (fmap head)) ((((.) (group)) (sort)))); putList :: Show a => [a] -> IO (); a15 = (((.) (putStrLn)) ((((.) (intercalate (map toChar [10]))) (map show)))); getModuleName :: GHC.HsModule GHC.GhcPs -> Maybe String; a8 = (((.) (fmap ((((.) (GHC.moduleNameString)) (GHC.unLoc))))) (GHC.hsmodName)); showElem :: Out.Outputable p => p -> String; a17 = (((.) (Out.showSDocUnsafe)) (Out.ppr)); a1 a7 = SYB.everything (++) (((SYB.mkQ ([])) (a7))); a3 a7 = SYB.everythingBut (++) (((SYB.mkQ (([],  False))) (a7))); a2 a7 a14 = a3 ((((&&&) (a7)) (a14))); destructName :: GHC.Name -> (String, Maybe String); a4 = (((.) (first GHC.occNameString)) (a5)); destructNameToOcc :: GHC.Name -> (GHC.OccName, Maybe String); a5 a12 = let a16 = (((<$>) (((((.) (GHC.moduleNameString)) (GHC.moduleName))))) (GHC.nameModule_maybe (GHC.unLoc a12))); a13 = ((($) (GHC.nameOccName)) (GHC.unLoc a12)) in (a13,  a16); destructRdrName :: GHC.RdrName -> (GHC.OccName, Maybe String); a6 (GHC.Unqual a11) = (a11,  Nothing); a6 (GHC.Qual a10 a11) = (a11,  ((($) (Just)) (GHC.moduleNameString a10))); a6 (GHC.Orig a9 a11) = (a11,  ((($) (Just)) (((($) (GHC.moduleNameString)) (GHC.moduleName a9))))); a6 (GHC.Exact a11) = (GHC.nameOccName a11,  (((<$>) (((((.) (GHC.moduleNameString)) (GHC.moduleName))))) (GHC.nameModule_maybe a11))); toChar :: Int -> Char; toChar = toEnum;