Overloaded literals
--------------------

Если хочется, к примеру, произвести какие-то действия над строковыми литералами
в дереве, то проще всего использовать Data.Generics.

Пример того, как это происходит:
```
everywhere (mkT changeStrings) ast

changeStrings :: HsLit GhcPs -> HsLit GhcPs
changeStrings (HsString _ str) = ...
```

Также с помощью монадической вариации `everywhereM` можно
проследить, было ли применено изменение и сделать те или иные
действия в зависимости от этого (к примеру, добавить новую декларацию).

Однако на практике при таком подходе наблюдаются странные вещи:
иногда новая декларация добавляется, хотя никаких изменений
применено не было.

К примеру модуль
```
module A where 
test = 1
```
станет
```
module A where
test = 1
newDecl = undefined
```

Выглядит странно, а причина того, почему это происходит, ещё страннее.

Рассмотрим перегруженные литералы в HsExpr:
```
data HsExpr p =
  ...
  | HsOverLit (XOverLitE p)
              (HsOverLit p)  -- ^ Overloaded literals
  ...
  
data HsOverLit p 
  = OverLit {   
      ol_ext :: (XOverLit p),
      ol_val :: OverLitVal, 
      ol_witness :: HsExpr p}
  | XOverLit  !(XXOverLit p)  

```

Поле `ol_witness` описывается в заметке `Note [Overloaded literals witnesses]` следующим образом:
> *Before* type checking, the HsExpr in an HsOverLit is the
> name of the coercion function, 'fromInteger' or 'fromRational'.
> *After* type checking, it is a witness for the literal, such as
> (fromInteger 3) or lit_78 
> This witness should replace the literal. 

При этом стоит заметить, что на этапе парсинга после `ol_witness` (насколько мне удалось увидеть в Parser.y и Hs/Utils.hs)
не используется по назначению, из-за чего в него записывают выражения `noExpr`.

Определение noExpr следующее:
```
noExpr :: HsExpr (GhcPass p)
noExpr = HsLit noExtField (HsString (SourceText  "noExpr") (fsLit "noExpr"))
```

Получается, что наша `changeStrings` из примера применится не только к строкам,
определённым пользователем, но и к строке `"noExpr"`. При печати это поле проигнорируется,
и мы не заметим ничего странного в тексте программы. Тем не менее, изменение будет
произведено фактически, что, соответственно, приведёт к выполнению заданного действия
(в нашем примере, добавление новой декларации).

Лично мне не ясно, почему было принято такое решение, и почему бы поле `ol_witness`
не сделать частью расширения.

На данный момент, расширения `HsOverLit` имеют такой вид:
```
type instance XOverLit GhcPs = NoExtField
type instance XOverLit GhcRn = Bool   -- Note [ol_rebindable]
type instance XOverLit GhcTc = OverLitTc
```

И кажется, что ничего не мешает сделать `ol_witness` частью только фаз `GhcRn` и `GhcTc`.

Далее, существует ещё `SyntaxExpr` и это тоже та ещё песня!


Проблема с операторами
----------------------

GHC парсит все операторы как левоассоциативные, а затем уже на этапе Renaming/Typechecking
меняет AST в соответствии с определением операторов.

Как тогда получить корректный ParsedSource с корректной ассоциативностью всех операторов для работы?

Насколько я понимаю, единственный вариант -- делать это руками. Дерево после проверки типов
совсем сильно меняется и его для наших целей не поиспользуешь. Однако проблема в том, что
для определения ассоциативности и приоритета (или одним словом fixity) нужно поработать,
совсем простого способа нет.

Смотрим, как компилятор ищет fixity операторов.
TcGlbEnv содержит поле tcg_fix_env, который содержит только локальные операторы.
А вот где искать остальную информацию не ясно.

Есть посмотреть в ghc/compiler/GHC/Rename и поискать слово fixity, то можно
найти функцию lookupFixityRn, которая приведёт нас к lookupFixityRn_help'.
В этой функции описано следующее:
1. Ищем оператор локально. Если нашли, что всё ок.
2. Если не находим и имя оператора локально, то используется fixity по-умолчанию.
3. Иначе вызывается вспомогательная функция lookup_imported.
  В ней происходит загрузка необходимого интерфейса, который экспортирует имя (по всей видимости),
  типа ModIface и уже в нём происходит поиск необходимой информации (в структуре есть необходимые поля).
  
У нас есть доступ до структур данных скомпилированного проекта, поэтому собрать необходимые данные
технически возможно. Однако мне потребовалось довольно много времени, чтобы определить, куда
конкретно нужно смотреть, но вроде получилось.
1. В монаде Ghc вызываем getSession и получаем HscEnv, в которой  содержится, кажется, _всё_.
2. Из этой структуры нужно достать две вещи: External Package State и Home Package Table. 
  External Package State (https://hackage.haskell.org/package/ghc-8.10.1/docs/HscTypes.html#t:ExternalPackageState)
  содержит информацию о внешних пакетах и модулях, а
  Home Package Table (https://hackage.haskell.org/package/ghc-8.10.1/docs/HscTypes.html#t:HomePackageTable)
  содержит информацию о текущем проекте. 
3. В каждой из них есть ModIface каждого модуля, которые мы ищем.       

В итоге, для определения fixity операторов есть такой вариант: получить информацию о всех
используемых модулях, из которых собираем информацию о fixity всех операторов.

Также, как вариант, можно обходить дерево после ренейминга RenamedSource), прямо в котором
в узлах OpApp записана информация о fixity соответствующих операторов.

Однако не ясно, какой вариант лучше. Второй больше похож на хак, а первый слишком громоздкий.
Так что до тех пор, пока я не пойму, что первый вариант может привести к ошибкам (ведь кто знает,
что в компиляторе там ещё происходит), буду использовать его.

Версии компиляторов
-------------------

TLDR: можно работать только с проектами, чьи версии компиляторов такие же, как у обфускатора.

Как обработать проект, чтобы скомпилировать модуль?
------------------------------------------------------

TODO: Hie-Bios

Экспорт симолов
---------------

Судя по всему, инстансы всегда экспортятся.

> Instance declarations cannot be explicitly named on import or export lists. All
> instances in scope within a module are always exported and any import brings
> all instances in from the imported module. Thus, an instance declaration is
> in scope if and only if a chain of import declarations leads to the module
> containing the instance declaration.

В таком случае, можно ли допустить переименование функций классов типов и соотвествующих
инстансов, если мы не экспортируем функции из классов типов?

Паттерны
--------

Обнаружила, что в конструкторе `BindStmt` аргумент `pat :: Pat ...` -- это, кажется, всегда конструктор `XPat`,
видимо, чтобы хранить Located. Почему в здесь нельзя сделать так, как оно с остальными -- не понятно.
